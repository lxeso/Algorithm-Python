# 백준 2828번 '사과 담기 게임'
# 문제 : 스크린은 N칸으로 나누어져 있다. 스크린의 아래쪽에는 M칸을 차지하는 바구니가 있다. (M<N) 플레이어는 게임을 하는 중에 바구니를 왼쪽이나 오른쪽으로 이동할 수 있다. 하지만, 바구니는 스크린의 경계를 넘어가면 안 된다. 가장 처음에 바구니는 왼쪽 M칸을 차지하고 있다.
# 스크린의 위에서 사과 여러 개가 떨어진다. 각 사과는 N칸중 한 칸의 상단에서 떨어지기 시작하며, 스크린의 바닥에 닿을때까지 직선으로 떨어진다. 한 사과가 바닥에 닿는 즉시, 다른 사과가 떨어지기 시작한다.
# 바구니가 사과가 떨어지는 칸을 차지하고 있다면, 바구니는 그 사과가 바닥에 닿을 때, 사과를 담을 수 있다. 상근이는 사과를 모두 담으려고 한다. 이때, 바구니의 이동 거리의 최솟값을 구하는 프로그램을 작성하시오.
# 입력 : 첫째 줄에 N과 M이 주어진다. (1 ≤ M < N ≤ 10) 둘째 줄에 떨어지는 사과의 개수 J가 주어진다. (1 ≤ J ≤ 20) 다음 J개 줄에는 사과가 떨어지는 위치가 순서대로 주어진다.
# 출력 : 모든 사과를 담기 위해서 바구니가 이동해야 하는 거리의 최솟값을 출력한다.

def solution(N, M, J, apples):
    left = 1  # 바구니의 초기 왼쪽 끝 위치
    right = M  # 바구니의 초기 오른쪽 끝 위치
    total_move = 0  # 바구니의 총 이동 거리
    
    for apple in apples:
        if apple < left:  # 사과가 바구니 왼쪽 밖에 떨어지는 경우
            move = left - apple # 바구니의 왼쪽 끝과 사과가 떨어지는 위치 사이의 거리를 계산
            total_move += move # 바구니가 이동한 거리를 total_move에 추가
            left -= move # 바구니 위치 갱신
            right -= move # 바구니 위치 갱신
        elif apple > right:  # 사과가 바구니 오른쪽 밖에 떨어지는 경우
            move = apple - right
            total_move += move
            left += move
            right += move
    
    return total_move

# 예시 입력 처리
N, M = map(int, input().split())  # 스크린의 너비 N과 바구니의 크기 M
J = int(input())  # 사과의 개수
apples = [int(input()) for _ in range(J)]  # 사과가 떨어지는 위치들
print(solution(N, M, J, apples))
