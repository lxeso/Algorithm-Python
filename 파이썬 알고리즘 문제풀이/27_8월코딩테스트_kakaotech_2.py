# 카카오테크 부트캠프 8월 코딩테스트 2번문제
# 문제 : 구름이가 그린 격자에서 출발지에서 목적지까지 도달하는 경로의 경우의 수를 계산하는 문제입니다. 단, 휴식이 적힌 칸을 밟지 않고 목적지에 도달해야 함
# 사용된 알고리즘 : 동적계획법(DP) (가능한 모든 경로를 효율적으로 계산)
# 입력 : 첫째 줄에 구름이가 그린 격자의 행의 개수 N, 열의 개수 M과 `휴식` 이 적힌 칸의 개수 K가 공백을 두고 주어진다. 둘째 줄부터 K개의 줄에 걸쳐 i번째 줄에 r[i], c[i]가 공백을 두고 주어진다. 이는 i번째 `휴식` 이 적힌 칸이 (r[i],c[i])임을 의미한다.
# 출력 : 출발지에서 시작해 `휴식` 이 적힌 칸에 이동하지 않고 최종 목적지에 도착하는 경우의 수를 10**9 + 7로 나눈 나머지를 출력한다.
# 경로 수 계산 : 구름이가 이동할 수 있는 방향은 아래쪽과 오른쪽입니다. 따라서, 특정 칸 (i, j)에 도달하는 경로 수는 (i-1, j)와 (i, j-1)에서 오는 경로의 합으로 계산됨
'''
알고리즘 및 지식
- 동적 계획법 (DP): DP는 큰 문제를 작은 문제로 나누어 해결하고, 작은 문제의 해결을 바탕으로 큰 문제를 해결하는 알고리즘 기법입니다. 이 문제에서는 각 칸까지의 경로 수를 DP 테이블에 저장하며, 이전 경로 수를 이용해 다음 경로 수를 계산합니다.
- 모듈러 연산: 결과가 매우 클 수 있기 때문에, 각 경로 수를 계산할 때마다 10^9 + 7로 나눈 나머지를 저장합니다.
'''
def solution():
    MOD = 10**9 + 7 # 결과를 모듈러 연살할 값
    N, M, K = map(int, input().split()) # 격자의 행(N), 열(M), 휴식 칸의 개수(K) 입력받기
    rest_positions = set() # 휴식 칸의 위치를 저장할 집합. 중복 금지

    # 휴식 칸 위치 입력받아 저장
    for _ in range(K):
        r, c = map(int, input().split())
        rest_positions.add((r, c))
    
    # DP 테이블 초기화
    dp = [[0] * (M + 1) for _ in range(N + 1)]
    dp[1][1] = 1 # 시작점에서 시작할 수 있는 경로의 수는 1

    # DP 테이블 채우기
    for i in range(1, N + 1):
        for j in range(1, M + 1):
            if (i, j) in rest_positions: # 현재 위치가 휴식 칸이면 경로 수는 0. 즉, (i, j)가 휴식 칸이라면, 이 칸으로 이동할 수 있는 모든 경로는 무효가 됨. 다시 말해, 이 칸에 도달한 경로는 이후 경로 계산에 사용되지 않으므로 경로 수를 0
                dp[i][j] = 0 
            else: # (i, j)가 휴식 칸이 아닌 경우
                if i > 1:
                    dp[i][j] += dp[i - 1][j] # 위쪽 칸에서 오는 경로 추가
                if j > 1:
                    dp[i][j] += dp[i][j-1] # 왼쪽 칸에서 오는 경로 추가

                dp[i][j] %= MOD # 경로 수를 모듈러 연산
    # 최종 목적지 (N, M)의 경로 수 출력
    print(dp[N][M])

'''
문제

구름이는 답답한 일상을 벗어나 새로운 것에 도전하려고 한다. 이는 바로 주사위를 던져서 떠나는 여행이다.
구름이는 여행을 위해 먼저 종이 위에 N개의 행과 M개의 열을 가진 격자를 그렸다.
이때, (i, j)는 i번째 행, j번째 열인 칸을 의미한다. 구름이는 격자를 그린 다음에 칸마다 가고 싶은 여행지를 적었다. 단, (1, 1)에는 구름이의 출발지를, (N, M )에는 구름이의 최종 목적지를, 임의의 K개의 칸에는 `휴식`을 적었다.
구름이는 이제 주사위를 던져 여행을 떠나려고 한다. 주사위는 1, 2, 3, 4, 5, 6 이 적혀 있는 정육면체 모양이며, 던질 때마다 나오는 눈금만큼 행의 번호나 열의 번호가 증가하는 방향으로 이동해야 한다. 즉, (r, c)에서 주사위를 던져 나온 눈금이
x라면, (r+ x, c) 또는 (r, c + x)로 이동할 수 있다. 단, 격자의 범위를 벗어날 수 없으며, (N, M)에 도착할 때까지 주사위를 던져 이동하기를 반복해야 한다.
구름이는 여행을 떠나기 직전에 문득 출발지에서 시작해 `휴식` 이 적힌 칸에 이동하지 않고 최종 목적지에 도착하는 경우의 수가 얼마나 되는지 궁금해졌다. 이때, `휴식` 이 적힌 칸에 이동한 것은 정확하게 `휴식` 이 적힌 칸으로 이동해서 주사위를 굴려야 하는 경우를 의미한다.
구름이가 그린 격자의 크기와 `휴식` 이 적힌 칸의 위치가 주어질 때, 출발지에서 시작해 `휴식` 이 적힌 칸에 이동하지 않고 최종 목적지에 도착하는 경우의 수를 알아보자.

입력

첫째 줄에 구름이가 그린 격자의 행의 개수 N, 열의 개수 M과 `휴식` 이 적힌 칸의 개수 K가 공백을 두고 주어진다.
둘째 줄부터 K개의 줄에 걸쳐 i번째 줄에 r[i], c[i]가 공백을 두고 주어진다. 이는 i번째 `휴식` 이 적힌 칸이 (r[i],c[i])임을 의미한다.

- 2 ≤ N, M ≤ 500
- O≤K≤N×M-2
- 1≤r[i] ≤N
- 1 ≤ c[i] ≤M
- 출발지나 최종 목적지인 칸이 동시에 `휴식` 이 적힌 칸인 경우는 주어지지 않는다.
- 서로 다른 두 개의 `휴식` 이 적힌 칸의 위치가 같은 경우는 주어지지 않는다.
- 입력으로 주어지는 모든 수는 정수이다.

출력
출발지에서 시작해 `휴식` 이 적힌 칸에 이동하지 않고 최종 목적지에 도착하는 경우의 수를 10**9 + 7로 나눈 나머지를 출력한다.
    
'''