# 미로 탐색 백준 2178번
# 문제 : 미로는 1(이동 가능), 0(이동 불가)로 이루어져 있음. 이러한 미로가 주어졌을 때, (1,1)에서 출발해서 (N,M)의 위치로 이동 시 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성해라. 한 칸에서 다른 칸으로 이동 시, 서로 인접한 칸으로만 이동 가능. 칸을 셀 때에는 시작 위치와 도착 위치도 포함함.
# 입력 : 첫째 줄에 두 정수 N, M(N은 2 이상, M은 100이하) 다음 N개의 줄에는 M개의 정수로 미로가 주어짐. 각각의 수들은 붙어서 입력으로 주어짐
# 출력 : 첫째 줄에 지나야 하는 최소의 칸 수를 출력. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어짐
from collections import deque

'''
101111
101010
101011
111011

결과 (2차원 리스트 형태인 그래프)
graph = [ 
    [1, 0, 1, 1, 1, 1],
    [1, 0, 1, 0, 1, 0],
    [1, 0, 1, 0, 1, 1],
    [1, 1, 1, 0, 1, 1] 
]
'''
def solution(N, M, maze):
    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)] # 현재 위치에서 (dx, dy) 를 더했을 때 상하좌우가 나오는 좌표들의 리스트. 리스트 안에 튜플들이 요소로 존재하는 구조

    queue = deque([(0,0)]) # 큐를 선언함과 동시에 리스트의 튜플 (0,0)으로 초기화

    while queue: # 탐색할 위치가 남아있는 동안
        #현재 위치
        x, y = queue.popleft() # BFS : 너비 우선 탐색이므로 현재 노드에서 가까운 노드부터 탐색함. 즉, 출발점에서 가까운 노드부터 차례로 탐색을 진행함. 큐의 맨 앞에 있는 요소가 가장 먼저 탐색된 노드이며, 그 노드에서 갈 수 있는 노드를 큐에 추가하게 됨. 여기서 popleft()가 아닌 pop()을 사용하게 되면 가장 나중에 추가된 노드부터 탐색하게 되므로 DFS처럼 작동됨
        # 첫번째 반복 시 (x,y) : (0,0) 이고, queue는 비어있게 됨
        for dx, dy in directions: # 상하좌우 한번씩 반복문으로 확인
            nx, ny = x+dx, y+dy # 현재 위치에서 상하좌우 중 한 곳으로 설정됨 (nx, ny)
            #첫번째 반복문에서 (nx, ny) : (-1,0)이 되므로 아래 if문에서 범위 밖으로 인식하여 자동으로 무시
            #두번째 반복문에서 (nx, ny) : (1,0)이 되는데, 미로 범위 안이고 인덱스의 값도 1이기 때문에 아래 if문으로 들어가 해당 인덱스의 값 갱신 후 탐색할 위치에 추가됨(큐에 추가됨)
            if 0<=nx<N and 0<=ny<M and maze[nx][ny] == 1: # 미로 범위 안에 존재하는 유효한 값(0이 아닌 1)이어야 함
                maze[nx][ny] = maze[x][y] + 1 # 2차원 리스트 인덱스 자체에 거리를 저장해두는 방식. 처음 시작인 maze[0][0]의 값이 1이므로 자동으로 다음 위치(인덱스)의 값은 2 -> 3 -> 4 형식으로 저장됨
                queue.append((nx, ny)) # 현재 위치 큐에 추가 = 다음 탐색할 위치
    
    return maze[N-1][M-1] # 문제상 (N, M)의 위치의 경우, 2차원 리스트 maze의 코드 상으론 maze[N-1][M-1]임. 위의 maze의 인덱스 값 자체에 +1씩 해주며 거리를 계산한 값을 저장시켜주었으므로 인덱스 위치만 반환하면 최단거리가 반환됨


N, M = map(int, input().split())
maze = [list(map(int, input())) for _ in range(N)] # maze가 2차원 리스트로 받아짐. 

print(solution(N, M, maze))